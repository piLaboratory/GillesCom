\documentclass[11pt, A4]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{Sweave}
\usepackage{natbib}
\usepackage{framed, color}
\usepackage{xspace}
\definecolor{shadecolor}{rgb}{0.9, 0.9, 0.9}
\setlength{\parindent}{0pt}
\setlength{\hoffset}{-0.5in}
\setlength{\textwidth}{6in}
\setlength{\voffset}{-0.1in}
\newcommand{\R}{\textnormal{\sffamily\bfseries R}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\SweaveOpts{eval=TRUE, keep.source=TRUE, echo=TRUE}
%\VignetteIndexEntry{Introduction to GillesCom}

\begin{document}

\title{Simulating ecological communities using a Gillespie process \\ Quick reference for \code{GillesCom} package}
\author{Paulo In\'acio Prado and Andre Chalom \\ Theoretical Ecology Lab \\ LAGE at the Dep of Ecology, USP, Brazil \\ 
  \url{http://ecologia.ib.usp.br/let/} \\ \url{prado@ib.usp.br}}

\date{August, 08, 2016}

\maketitle

@ 
<<R setup, echo=FALSE, >>=
options(width=60, continue=" ")
set.seed(42)
@ %def 

\section{Introduction}

This package supposes some familiarity with the package ``sads'', available on CRAN, by the same authors plus 
Miranda, M., and with the concepts related to Species Abundance Distributions. 


%%% TODO

\section{Installation}

The package is currently available only from source on Github, can be installed in \R with the commands:

@ 
<<installation, eval=FALSE>>=
install.packages('devtools')
library(devtools)
install_github('piLaboratory/GillesCom')
@ %def 

then loaded by

<<load, eval=TRUE>>=
library(GillesCom)
@ %def 

\section{Generating a metacommunity}

One of the fundamental processes that governs the dynamics of a community is the arrival of migrants from
a regional pool of species. The simplest model for the probability of arrival of each species is to
assume that all individuals have the same probability of migration, so that the probability that a migrant
is from species $i$ is directly proportional to the abundance of species $i$ in the regional pool. 

The function \code{ls\_migration} can be used to generate the migration rates of several species from a logseries 
metacommunity of expected \footnote{This function generates $S$ values of abundances from a logseries distribution.
Therefore the total number of individuals in the simulated metacommunity varies among runs of \code{ls\_migration}, 
but has an expected value of $J$} size $J$, and $S$ species with a given Fisher's $\alpha$ and a per 
species migration rate of $m$:
<<migration>>=
migration <- ls_migration(J = 1e6, alpha = 50, m = 1)
(N <- length(migration$m))
@

Now $N$ is the number of species in the metacommunity. Let us now generate a matrix representing the
interactions between species. There are three more widely used choices: the species may not interact at all
with one another (so the matrix will have all zeros on non-diagonal elements), the species may affect
one another exactly as they affect an individual of the same species (which is, in a sense, neutral), or 
the matrix may have random competition terms with one another. These matrices can be constructed using the 
following functions:
<<interaction>>=
non.interact <- diag(N)
neutral <- ones(N)
random <- interaction_matrix(N, stren = 0.1, con=1)
@

The additional parameters for function \code{interaction\_matrix} represent the strength of the competition and 
the connectivity of the interaction matrix.

The interaction matrix may also be constructed using a Gamma distribution for generating the competition strengths;
see \cite{Kessler2015} for more details.

\section{Initializing the community}

For performance reasons, this package works with an Rcpp module encapsulating the actual simulation data.
This is mostly transparent to the user, but some care must be exercised in order to avoid some pitfalls
of the Rcpp integration. In order to initialize a community, use the function 
\code{Init\_Community}, and assign the resulting object to a variable.
<<Init>>=
com = Init_Community(abundance=rep(0, N), interaction=random, b=1, m = migration)
@

The arguments $m$, $b$ and $d0$ of this function are expanded to vectors of the appropriate length, if
necessary.

\section{Running and examining the simulation}
In order to run simulation cycles of the birth, death and migration process, execute the function \code{bdm}:
<<bdm>>=
bdm(com)
bdm(com, count = 1e4, progress="none")
bdm(com, time = 2, progress="none")
@

The function \code{bdm} accepts the number of cycles to be run as the second parameter. 
Optionally, you may specify the units of simulated time that you want to run as the \code{time} argument.
The last parameter controls whether a progress bar should be displayed on the screen.

Notice that \code{bdm} does not return anything. It affects directly the object received as the first parameter.

In order to query about the
current status of the simulation, use the slots in the \code{Community} class (see \code{?Community} for a full list:
<<functions>>=
# Current abundance vector
ab <- as.numeric(com$abundance)
ab[ab > 0]
# Simulation internal time elapsed
print(com$time)
# Simulation cycles elapsed
print(com$cycles)
# `Trajectories` saves a line for each time period elapsed (starting with 0):
dim(com$trajectories[[1]])
@

Please note that the result from the slot \code{abundance} is \emph{not} the same as the last line 
in \code{trajectories}. This is because the lines in \code{trajectories} is recorded whenever
the clock reaches a designated interval (by default, every unit of time), while \code{abundance}
gives the abundance at precisely the instant given by the slot \code{time}.

Taking a closer look at the \code{trajectories} object, we see that it is a list with three
components: a matrix with the abundances of each species at each snapshot, and two vectors that
can be used to see the exact time and elapsed cycles at each snapshot:

<<trajectories>>=
str(com$trajectories)
@

Some diagnostic plots may be generated with:
<<diagPlot, fig=TRUE>>=
diagPlots(com)
@

Notice that the x-axis on the plots is given by units of simulated time, \emph{NOT} cycles.
It should be clear from this graphics that the simulated community is far from equilibrium.

There are currently two plots that help to visualize the evolution of the community over time:
\code{radOverTime} and \code{octavOverTime}. Both draw lines representing the radplot and the
octavplot of the community as time progresses, with lighter lines representing older
times, and darker lines representing more modern times. A blue line is superimposed, representing
the current community:

<<radOverTime, fig=TRUE>>=
radOverTime(com)
@
<<octavOverTime, fig=TRUE>>=
octavOverTime(com)
@

\section{Environmental stochasticity}
So far all rates were constant for each species. Currently it is posible to make carrying capacities vary over time. 
This can be used to simulate some kind of environmental variation in the demographic rates, such as cycles or
environmental stochasticity.
The following lines of code generate a data frame with two columns, the first representing the time and the second representing a common multiplier for the birth rates of all species due to environmental stochasticity. With the parameters below, a typical run will be constrained in the 0.25 - 4 interval.

<<stochasticity>>=
K.df = stoch_environment(time = 100, sd = 0.01)
plot(K.df, type='l')
@

Then, we generate a community under the effect of this stochastic carrying capacity multiplier as:
<<>>=
stochcom = Init_Community(50, environmental=K.df)
bdm(stochcom, time=30)
diagPlots(stochcom)
@

Finally, the \code{environmental.strength} parameter can be used to individually tune
how much each species is affected by the environmental fluctuations. First, let us
build a severely artificial \code{environmental} data frame to illustrate this more
clearly. Here, the environment is at the default on time zero, gets better up to being
twice as welcoming on time 100 and then falls in quality to almost a desert on time 200:

<<>>=
K.df = data.frame(time = c(0, 100, 200), K = c(1, 2, 0.1))
plot(K.df, type='l')
@

Now, we construct a community with only 4 non-interacting species, all with the same
carrying capacity. The first species will be fully affected by the environment (\code{str = 1}),
the second will only fell half the effect of the environment (\code{str = 0.5}), so when the environmental 
multiplier is 2, the realized K for the species 1 will be 200, and for the species 2 it will be 150.
The third species is totally unaffected by the environment, so it will remain on K = 100. And finally, the
fourth species will be reversely affected by the environment (maybe it thrives on desertic conditions?),
so its carrying capacity will be 0 on time 100 and almost 200 at time 200. The plot below shows the population size evolution for each species:

<<>>=
str = c(1, 0.5, 0, -1)
stochcom2 = Init_Community(rep(100,4), interaction=diag(4), K = 100,
                           environmental=K.df,
                           environmental.strength = str)
bdm(stochcom2, time=200)
matplot(stochcom2$trajectories[[1]], type='l')
legend("topleft", legend=c("Fully affected", "Half affected", "Not affected", "Reverse affected"), col=1:4, lty=1:4)
@
\section{File persistence}

It may be helpful to save the simulation state to disk, in order to carry out analyses later
or in other computer. To save all relevant information to the simulation, you can use the
\code{GillesComToFile} function, and to load a file saved by this function, use \code{GillesComFromFile}.

The saving function stores the status of the random number generator, to allow for reproducible
simulations; however, the loading function cannot automatically restore this status. However, we provide another
function to restore the random seed:

<<load, eval = FALSE>>=
.Random.seed <- SeedFromFile("data.rda")
@

\section{Bugs and issues}
\label{sec:bugs-issues}

The package project is hosted on GitHub (\url{https://github.com/piLaboratory/GillesCom/}). 
Please report bugs and issues and give us your feedback at 
\url{https://github.com/piLaboratory/GillesCom/issues}.

\bibliographystyle{apalike}
\bibliography{GillesCom}
\end{document}
